-- Player logic


-- pre-hashing ids improves performance
local msg_contact_point_response = hash("contact_point_response")
local msg_animation_done = hash("animation_done")
local group_obstacle = hash("ground")
local input_left = hash("left")
local input_right = hash("right")
local input_jump = hash("jump")
local anim_walk = hash("walk")
local anim_idle = hash("idle")
local anim_jump = hash("jump")
local anim_fall = hash("fall")

local ColyseusClient = require "colyseus.client"

local client
local room

function init(self)
    -- this lets us handle input in this script
    msg.post(".", "acquire_input_focus")

    -- activate camera attached to the player collection
    -- this will send camera updates to the render script
    msg.post("camera", "acquire_camera_focus")

    self.anim = nil

    -- Add initialization code here
    client = ColyseusClient.new("ws://localhost:2567")

    -- join chat room
    client:join("my_room", {}, function(err, _room)
        if err then
            print("JOIN ERROR: " .. err)
            return
        end

        room = _room

        room:on("statechange", function(state)
            print(room.sessionId)
            --for id, v in pairs(state.players.items) do
            --    print(id)
            --end
            if state.players[room.sessionId] then
                pprint(state.players[room.sessionId])
                pos = vmath.vector3()
                pos.x = tonumber(state.players[room.sessionId].x)*64;
                pos.y = tonumber(state.players[room.sessionId].y)*64;
                pos.z = 0
                go.set_position(pos)
                print(pos.x, pos.y)
            end
        end)
    end)
end

local function play_animation(self, anim)
    -- only play animations which are not already playing
    if self.anim ~= anim then
        -- tell the sprite to play the animation
        sprite.play_flipbook("#sprite", anim)
        -- remember which animation is playing
        self.anim = anim
    end
end

local function update_animations(self)
    -- make sure the player character faces the right way
    --sprite.set_hflip("#sprite", self.velocity.x < 0)
    -- make sure the right animation is playing
    --if self.ground_contact then
    --	if self.velocity.x == 0 then
    --		play_animation(self, anim_idle)
    --	else
    --		play_animation(self, anim_walk)
    --	end
    --else
    --	if self.velocity.y > 0 then
    --		play_animation(self, anim_jump)
    --	else
    --		play_animation(self, anim_fall)
    --	end
    --end
end

function update(self, dt)

    --go.set_position(pos)

    -- update animations based on state (ground, air, move and idle)
    update_animations(self)

end

function on_message(self, message_id, message, sender)

end

function on_input(self, action_id, action)
    if action_id == input_left then
        walk(self, -action.value)
    elseif action_id == input_right then
        walk(self, action.value)
    elseif action_id == input_jump then
        if action.pressed then
            jump(self)
        elseif action.released then
            abort_jump(self)
        end
    end
end